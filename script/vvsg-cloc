#!/usr/bin/env node

/**
 * Checks TypeScript files for adherence to the VVSG 1.0 spec regarding module
 * line count. Relevant language below:
 *
 * | Excluding code generated by commercial code generators, is written in
 * | small and easily identifiable modules, with no more than 50% of all modules
 * | exceeding 60 lines in length, no more than 5% of all modules exceeding 120
 * | lines in length, and no modules exceeding 240 lines in length. “Lines” in
 * | this context, are defined as executable statements or flow control
 * | statements with suitable formatting and comments. The reviewer should
 * | consider the use of formatting, such as blocking into readable units, which
 * | supports the intent of this requirement where the module itself exceeds the
 * | limits. The vendor shall justify any module lengths exceeding this standard
 *
 * Make sure you have the `cloc` package installed:
 *
 *   # Ubuntu
 *   apt-get install cloc
 *
 *   # macOS
 *   brew install cloc
 */

// @ts-check

const { default: chalk } = require('chalk')
const cp = require('child_process')
const { promisify } = require('util')
const execFile = promisify(cp.execFile)

/**
 * CLOC per module with the maximum percentage of modules that meet or exceed
 * that amount.
 */
const minCLOCRequirements = new Map([
  [60, 0.5],
  [120, 0.05],
  [240, 0],
])

/**
 * @typedef {Object<string, Stat> & StatsMeta} Stats
 */

/**
 * @typedef {object} StatsMeta
 * @property {StatsHeader} header
 * @property {StatSummary} SUM
 */

/**
 * @typedef {object} StatsHeader
 * @property {string} cloc_url
 * @property {string} cloc_version
 * @property {number} elapsed_seconds
 * @property {number} n_files
 * @property {number} n_lines
 * @property {number} files_per_second
 * @property {number} lines_per_second
 */

/**
 * @typedef {object} StatSummary
 * @property {number} blank
 * @property {number} comment
 * @property {number} code
 * @property {number} nFiles
 */

/**
 * @typedef {object} Stat
 * @property {number} blank
 * @property {number} comment
 * @property {number} code
 * @property {string} language
 */

async function main(out = process.stdout) {
  const { stdout, stderr } = await execFile('cloc', [
    '--vcs',
    'git',
    '--json',
    '--by-file',
    '--include-lang=TypeScript',
  ])

  if (stderr.length) {
    console.error('ERROR:', stderr)
  }

  /** @type {Stats} */
  const stats = JSON.parse(stdout)
  /** @type {Map<number, Set<[string, Stat]>>} */
  const filesByMinCLOC = new Map(
    [...minCLOCRequirements.keys()].map(minCLOC => [minCLOC, new Set()])
  )
  const filesByCLOCRange = new Map(
    [...minCLOCRequirements.keys()].map(minCLOC => [minCLOC, new Set()])
  )

  for (const [file, stat] of Object.entries(stats)) {
    if (file === 'header' || file === 'SUM') {
      continue
    }

    const count = stat.code
    for (const [minCLOC, files] of filesByMinCLOC) {
      if (minCLOC <= count) {
        files.add([file, stat])
      }
    }

    for (const [minCLOC, files] of [...filesByCLOCRange].reverse()) {
      if (minCLOC <= count) {
        files.add([file, stat])
        break
      }
    }
  }

  for (const [minCLOC, files] of filesByCLOCRange) {
    out.write(`${chalk.bold(`${minCLOC}+ CLOC Files:`)}\n`)

    for (const [file, stat] of [...files].sort(
      ([, aStat], [, bStat]) => aStat.code - bStat.code
    )) {
      out.write(
        `${chalk.yellow(stat.code.toString().padStart(3, ' '))} ${file}\n`
      )
    }

    out.write('\n')
  }

  out.write(`${chalk.bold('Summary:')}\n`)

  for (const [minCLOC, files] of filesByMinCLOC) {
    const actual = files.size / stats.SUM.nFiles
    const expected = minCLOCRequirements.get(minCLOC)

    if (actual > expected) {
      process.exitCode = 1
    }

    out.write(`${formatCLOCStat(minCLOC, actual, expected)}\n`)
  }
}

/**
 *
 * @param {number} minCLOC
 * @param {number} actual
 * @param {number} expected
 */
function formatCLOCStat(minCLOC, actual, expected) {
  const color = actual <= expected ? chalk.green : chalk.red
  return color(
    `${minCLOC.toString().padStart(3, ' ')}+ CLOC: ${Math.round(actual * 100)
      .toString()
      .padStart(2, ' ')}% (<= ${Math.round(
      expected * 100
    ).toString()}% expected)`
  )
}

main().catch(error => {
  console.error(error)
  process.exitCode = -1
})
